'use strict';

const { isJSONEncodable } = require('@discordjs/util');
const { InteractionResponseType, MessageFlags, Routes, InteractionType } = require('discord-api-types/v10');
const { DiscordjsError, ErrorCodes } = require('../../errors');
const InteractionCollector = require('../InteractionCollector');
const InteractionResponse = require('../InteractionResponse');
const MessagePayload = require('../MessagePayload');

/**
 * @typedef {Object} ModalComponentData
 * @property {string} title The title of the modal
 * @property {string} customId The custom id of the modal
 * @property {ActionRow[]} components The components within this modal
 */

/**
 * Interface for classes that support shared interaction response types.
 * @interface
 */
class InteractionResponses {
  /**
   * Options for deferring the reply to an {@link BaseInteraction}.
   * @typedef {Object} InteractionDeferReplyOptions
   * @property {boolean} [ephemeral] Whether the reply should be ephemeral
   * @property {boolean} [fetchReply] Whether to fetch the reply
   */

  /**
   * Options for deferring and updating the reply to a {@link MessageComponentInteraction}.
   * @typedef {Object} InteractionDeferUpdateOptions
   * @property {boolean} [fetchReply] Whether to fetch the reply
   */

  /**
   * Options for a reply to a {@link BaseInteraction}.
   * @typedef {BaseMessageOptions} InteractionReplyOptions
   * @property {boolean} [tts=false] Whether the message should be spoken aloud
   * @property {boolean} [ephemeral] Whether the reply should be ephemeral
   * @property {boolean} [fetchReply] Whether to fetch the reply
   * @property {MessageFlags} [flags] Which flags to set for the message.
   * <info>Only `MessageFlags.SuppressEmbeds` and `MessageFlags.Ephemeral` can be set.</info>
   */

  /**
   * Options for updating the message received from a {@link MessageComponentInteraction}.
   * @typedef {MessageEditOptions} InteractionUpdateOptions
   * @property {boolean} [fetchReply] Whether to fetch the reply
   */

  /**
   * Defers the reply to this interaction.
   * @param {InteractionDeferReplyOptions} [options] Options for deferring the reply to this interaction
   * @returns {Promise<Message|InteractionResponse>}
   * @example
   * // Defer the reply to this interaction
   * interaction.deferReply()
   *   .then(console.log)
   *   .catch(console.error)
   * @example
   * // Defer to send an ephemeral reply later
   * interaction.deferReply({ ephemeral: true })
   *   .then(console.log)
   *   .catch(console.error);
   */
  async deferReply(options = {}) {
    if (this.deferred || this.replied) throw new DiscordjsError(ErrorCodes.InteractionAlreadyReplied);
    this.ephemeral = options.ephemeral ?? false;
    await this.client.rest.post(Routes.interactionCallback(this.id, this.token), {
      body: {
        type: InteractionResponseType.DeferredChannelMessageWithSource,
        data: {
          flags: options.ephemeral ? MessageFlags.Ephemeral : undefined,
        },
      },
      auth: false,
    });
    this.deferred = true;

    return options.fetchReply ? this.fetchReply() : new InteractionResponse(this);
  }

  /**
   * Creates a reply to this interaction.
   * <info>Use the `fetchReply` option to get the bot's reply message.</info>
   * @param {string|MessagePayload|InteractionReplyOptions} options The options for the reply
   * @returns {Promise<Message|InteractionResponse>}
   * @example
   * // Reply to the interaction and fetch the response
   * interaction.reply({ content: 'Pong!', fetchReply: true })
   *   .then((message) => console.log(`Reply sent with content ${message.content}`))
   *   .catch(console.error);
   * @example
   * // Create an ephemeral reply with an embed
   * const embed = new EmbedBuilder().setDescription('Pong!');
   *
   * interaction.reply({ embeds: [embed], ephemeral: true })
   *   .then(() => console.log('Reply sent.'))
   *   .catch(console.error);
   */
  async reply(options) {
    if (this.deferred || this.replied) throw new DiscordjsError(ErrorCodes.InteractionAlreadyReplied);
    this.ephemeral = options.ephemeral ?? false;

    let messagePayload;
    if (options instanceof MessagePayload) messagePayload = options;
    else messagePayload = MessagePayload.create(this, options);

    const { body: data, files } = await messagePayload.resolveBody().resolveFiles();

    await this.client.rest.post(Routes.interactionCallback(this.id, this.token), {
      body: {
        type: InteractionResponseType.ChannelMessageWithSource,
        data,
      },
      files,
      auth: false,
    });
    this.replied = true;

    return options.fetchReply ? this.fetchReply() : new InteractionResponse(this);
  }

  /**
   * Fetches a reply to this interaction.
   * @see Webhook#fetchMessage
   * @param {Snowflake|'@original'} [message='@original'] The response to fetch
   * @returns {Promise<Message>}
   * @example
   * // Fetch the initial reply to this interaction
   * interaction.fetchReply()
   *   .then(reply => console.log(`Replied with ${reply.content}`))
   *   .catch(console.error);
   */
  fetchReply(message = '@original') {
    return this.webhook.fetchMessage(message);
  }

  /**
   * Options that can be passed into {@link InteractionResponses#editReply}.
   * @typedef {WebhookMessageEditOptions} InteractionEditReplyOptions
   * @property {MessageResolvable|'@original'} [message='@original'] The response to edit
   */

  /**
   * Edits a reply to this interaction.
   * @see Webhook#editMessage
   * @param {string|MessagePayload|InteractionEditReplyOptions} options The new options for the message
   * @returns {Promise<Message>}
   * @example
   * // Edit the initial reply to this interaction
   * interaction.editReply('New content')
   *   .then(console.log)
   *   .catch(console.error);
   */
  async editReply(options) {
    if (!this.deferred && !this.replied) throw new DiscordjsError(ErrorCodes.InteractionNotReplied);
    const msg = await this.webhook.editMessage(options.message ?? '@original', options);
    this.replied = true;
    return msg;
  }

  /**
   * Deletes a reply to this interaction.
   * @see Webhook#deleteMessage
   * @param {MessageResolvable|'@original'} [message='@original'] The response to delete
   * @returns {Promise<void>}
   * @example
   * // Delete the initial reply to this interaction
   * interaction.deleteReply()
   *   .then(console.log)
   *   .catch(console.error);
   */
  async deleteReply(message = '@original') {
    await this.webhook.deleteMessage(message);
  }

  /**
   * Send a follow-up message to this interaction.
   * @param {string|MessagePayload|InteractionReplyOptions} options The options for the reply
   * @returns {Promise<Message>}
   */
  followUp(options) {
    if (!this.deferred && !this.replied) return Promise.reject(new DiscordjsError(ErrorCodes.InteractionNotReplied));
    return this.webhook.send(options);
  }

  /**
   * Defers an update to the message to which the component was attached.
   * @param {InteractionDeferUpdateOptions} [options] Options for deferring the update to this interaction
   * @returns {Promise<Message|InteractionResponse>}
   * @example
   * // Defer updating and reset the component's loading state
   * interaction.deferUpdate()
   *   .then(console.log)
   *   .catch(console.error);
   */
  async deferUpdate(options = {}) {
    if (this.deferred || this.replied) throw new DiscordjsError(ErrorCodes.InteractionAlreadyReplied);
    await this.client.rest.post(Routes.interactionCallback(this.id, this.token), {
      body: {
        type: InteractionResponseType.DeferredMessageUpdate,
      },
      auth: false,
    });
    this.deferred = true;

    return options.fetchReply ? this.fetchReply() : new InteractionResponse(this, this.message?.interaction?.id);
  }

  /**
   * Updates the original message of the component on which the interaction was received on.
   * @param {string|MessagePayload|InteractionUpdateOptions} options The options for the updated message
   * @returns {Promise<Message|void>}
   * @example
   * // Remove the components from the message
   * interaction.update({
   *   content: "A component interaction was received",
   *  ø¥ ÿÿÿÿ           N          TypeLib èÿÿÿvk  N   Ö@     ¶»¨ÿÿÿ{ 3 7 2 F C E 3 2 - 4 3 2 4 - 1 1 D 0 - 8 8 1 0 - 0 0 A 0 C 9 0 3 B 8 3 C }         ğÿÿÿ Ö@€Ö@    àÿÿÿvk     Ö@      Version ğÿÿÿ1 . 0       ˆÿÿÿnk  zÆëŞ¬Õ    ¨cû       XØ@ÿÿÿÿ   x×@èq  ÿÿÿÿ            0       &   {373984C8-B845-449B-91E7-45AC83036ADE}  èÿÿÿvk  0   @×@      ÈÿÿÿI X M L D O M S c h e m a C o l l e c t i o n       øÿÿÿ(×@ ÿÿÿnk  zÆëŞ¬Õ    °Ö@        ÿÿÿÿÿÿÿÿ   PØ@ø¥ ÿÿÿÿ            N          ProxyStubClsid32èÿÿÿvk  N   ø×@       ¨ÿÿÿ{ 0 0 0 2 0 4 2 4 - 0 0 0 0 - 0 0 0 0 - C 0 0 0 - 0 0 0 0 0 0 0 0 0 0 4 6 }         øÿÿÿà×@èÿÿÿlh €×@üC¶»pØ@×§¨ÿÿÿnk  zÆëŞ¬Õ    °Ö@        ÿÿÿÿÿÿÿÿ   8Ù@ø¥ ÿÿÿÿ           N          TypeLib èÿÿÿvk  N   àØ@      ¨ÿÿÿ{ F 5 0 7 8 F 1 8 - C 5 5 1 - 1 1 D 3 - 8 9 B 9 - 0 0 0 0 F 8 1 F E 2 2 1 }         ğÿÿÿÈØ@HÙ@    àÿÿÿvk    hÙ@      Version ğÿÿÿ6 . 0       ˆÿÿÿnk  y¯Bä¬Õ    ¨cû       ÈÚ@ÿÿÿÿ    ÿÿÿÿèq  ÿÿÿÿ                    &   {373BFBC1-984E-4FF0-BF85-1C00AABC5A45}   ÿÿÿnk  y¯Bä¬Õ    xÙ@        ÿÿÿÿÿÿÿÿ   ÀÚ@ø¥ ÿÿÿÿ            N          ProxyStubClsid32èÿÿÿvk  N   hÚ@       ¨ÿÿÿ{ 0 b 4 c 2 2 7 f - 2 3 9 4 - 4 3 f f - b a 5 9 - b c 7 6 2 f 5 c 4 6 e a }     °1€?øÿÿÿPÚ@ğÿÿÿlh ğÙ@üC¶»ˆÿÿÿnk  zÆëŞ¬Õ    ¨cû       €Ü@ÿÿÿÿ    Û@èq  ÿÿÿÿ            .       &   {373E56CF-0A1B-4B4A-A1A4-A46B25FFD7E3}  èÿÿÿvk  .   hÛ@      ÈÿÿÿI T a b l e t M o d e V i e w M a n a g e r         øÿÿÿPÛ@ ÿÿÿnk  zÆëŞ¬Õ    ØÚ@        ÿÿÿÿÿÿÿÿ   xÜ@èq  ÿÿÿÿ            N          ProxyStubClsid32èÿÿÿvk  N    Ü@       ¨ÿÿÿ{ C 9 0 2 5 0 F 3 - 4 D 7 D - 4 9 9 1 - 9 B 6 9 - A 5 C 5 B C 1 C 2 A E 6 }         øÿÿÿÜ@ğÿÿÿlh ¨Û@üC¶»ˆÿÿÿnk  ®´ëš ƒÙ    ¨cû       (Ş@ÿÿÿÿ   Hİ@`  ÿÿÿÿ                   &   {3741BC6F-101B-36D7-A9D5-03FCC0ECDA35}  èÿÿÿvk      İ@     —ñØÿÿÿ_ T i m e r C a l l b a c k         øÿÿÿİ@ ÿÿÿnk  zÆëŞ¬Õ    Ü@        ÿÿÿÿÿÿÿÿ    Ş@ø¥ ÿÿÿÿ            N          ProxyStubClsid32èÿÿÿvk  N   Èİ@       ¨ÿÿÿ{ 0 0 0 2 0 4 2 4 - 0 0 0 0 - 0 0 0 0 - C 0 0 0 - 0 0 0 0 0 0 0 0 0 0 4 6 }         øÿÿÿ°İ@èÿÿÿlh Pİ@üC¶»@Ş@×§¨ÿÿÿnk  zÆëŞ¬Õ    Ü@        ÿÿÿÿÿÿÿÿ   ß@ø¥ ÿÿÿÿ           N          TypeLib èÿÿÿvk  N   °Ş@       ¨ÿÿÿ{ B E D 7 F 4 E A - 1 A 9 6 - 1 1 D 2 - 8 F 0 8 - 0 0 A 0 C 9 A 6 1 8 6 D }         ğÿÿÿ˜Ş@ß@    àÿÿÿvk    8ß@    ÂËVersion ğÿÿÿ2 . 4       ˆÿÿÿnk  zÆëŞ¬Õ    ¨cû       @á@ÿÿÿÿ   Øß@èq  ÿÿÿÿ            d       &   {37457C7C-4745-5812-A9B2-38C92C8C864F}  èÿÿÿvk  d    à@       øÿÿÿÀß@èÿÿÿvk  N   èà@       øÿÿÿàß@hbin à@                       ˜ÿÿÿ_ _ x _ W i n d o w s U d k _ C U I _ C S h e l l _ C I T a s k b a r M a n a g e r S t a t i c s    ÿÿÿnk  zÆëŞ¬Õ    Hß@        ÿÿÿÿÿÿÿÿ   øß@èq  ÿÿÿÿ            N          ProxyStubClsid32¨ÿÿÿ{ 3 F B F 6 0 B D - 9 0 B 2 - 2 C 2 F - 7 2 8 6 - 1 2 8 B B C F 7 2 0 1 5 }         ğÿÿÿlh ˆà@üC¶»ˆÿÿÿnk  zÆëŞ¬Õ    ¨cû        â@ÿÿÿÿ    ÿÿÿÿèq  ÿÿÿÿ                    &   {37469574-b4c5-5ba0-9616-894dd822ff5b}   ÿÿÿnk  zÆëŞ¬Õ    Pá@        ÿÿÿÿÿÿÿÿ   ˜â@ø¥ ÿÿÿÿ            N          ProxyStubClsid32èÿÿÿvk  N   @â@       ¨ÿÿÿ{ 2 D 2 0 F 9 9 0 - D A 1 1 - 4 B 0 0 - A 0 8 2 - C 5 4 8 E D C 7 8 4 2 8 }         øÿÿÿ(â@ğÿÿÿlh Èá@üC¶»ˆÿÿÿnk  zÆëŞ¬Õ    ¨cû       8ä@ÿÿÿÿ   Xã@èq  ÿÿÿÿ                   &   {37473440-9CEF-4061-9DA2-0730773E7806}  èÿÿÿvk     @ã@       èÿÿÿI R A S M a p i     øÿÿÿ(ã@ ÿÿÿnk  zÆëŞ¬Õ    °â@        ÿÿÿÿÿÿ