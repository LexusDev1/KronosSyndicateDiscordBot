'use strict';

const { Collection } = require('@discordjs/collection');
const { ApplicationCommandPermissionType, RESTJSONErrorCodes, Routes } = require('discord-api-types/v10');
const BaseManager = require('./BaseManager');
const { DiscordjsError, DiscordjsTypeError, ErrorCodes } = require('../errors');

/**
 * Manages API methods for permissions of Application Commands.
 * @extends {BaseManager}
 */
class ApplicationCommandPermissionsManager extends BaseManager {
  constructor(manager) {
    super(manager.client);

    /**
     * The manager or command that this manager belongs to
     * @type {ApplicationCommandManager|ApplicationCommand}
     * @private
     */
    this.manager = manager;

    /**
     * The guild that this manager acts on
     * @type {?Guild}
     */
    this.guild = manager.guild ?? null;

    /**
     * The id of the guild that this manager acts on
     * @type {?Snowflake}
     */
    this.guildId = manager.guildId ?? manager.guild?.id ?? null;

    /**
     * The id of the command this manager acts on
     * @type {?Snowflake}
     */
    this.commandId = manager.id ?? null;
  }

  /**
   * The APIRouter path to the commands
   * @param {Snowflake} guildId The guild's id to use in the path,
   * @param {Snowflake} [commandId] The application command's id
   * @returns {string}
   * @private
   */
  permissionsPath(guildId, commandId) {
    if (commandId) {
      return Routes.applicationCommandPermissions(this.client.application.id, guildId, commandId);
    }

    return Routes.guildApplicationCommandsPermissions(this.client.application.id, guildId);
  }

  /* eslint-disable max-len */
  /**
   * The object returned when fetching permissions for an application command.
   * @typedef {Object} ApplicationCommandPermissions
   * @property {Snowflake} id The role, user, or channel's id. Can also be a
   * {@link https://discord.com/developers/docs/interactions/application-commands#application-command-permissions-object-application-command-permissions-constants permission constant}.
   * @property {ApplicationCommandPermissionType} type Whether this permission is for a role or a user
   * @property {boolean} permission Whether the role or user has the permission to use this command
   */
  /* eslint-enable max-len */

  /**
   * Options for managing permissions for one or more Application Commands
   * <warn>When passing these options to a manager where `guildId` is `null`,
   * `guild` is a required parameter</warn>
   * @typedef {Object} BaseApplicationCommandPermissionsOptions
   * @property {GuildResolvable} [guild] The guild to modify / check permissions for
   * <warn>Ignored when the manager has a non-null `guildId` property</warn>
   * @property {ApplicationCommandResolvable} [command] The command to modify / check permissions for
   * <warn>Ignored when the manager has a non-null `commandId` property</warn>
   */

  /**
   * Fetches the permissions for one or multiple commands. Providing the client's id as the "command id" will fetch
   * *only* the guild level permissions
   * @param {BaseApplicationCommandPermissionsOptions} [options] Options used to fetch permissions
   * @returns {Promise<ApplicationCommandPermissions[]|Collection<Snowflake, ApplicationCommandPermissions[]>>}
   * @example
   * // Fetch permissions for one command
   * guild.commands.permissions.fetch({ command: '123456789012345678' })
   *   .then(perms => console.log(`Fetched ${perms.length} overwrites`))
   *   .catch(console.error);
   * @example
   * // Fetch permissions for all commands in a guild
   * client.application.commands.permissions.fetch({ guild: '123456789012345678' })
   *   .then(perms => console.log(`Fetched permissions for ${perms.size} commands`))
   *   .catch(console.error);
   * @example
   * // Fetch guild level permissions
   * guild.commands.permissions.fetch({ command: client.user.id })
   *   .then(perms => console.log(`Fetched ${perms.length} guild level permissions`))
   *   .catch(console.error);
   */
  async fetch({ guild, command } = {}) {
    const { guildId, commandId } = this._validateOptions(guild, command);
    if (commandId) {
      const data = await this.client.rest.get(this.permissionsPath(guildId, commandId));
      return data.permissions;
    }

    const data = await this.client.rest.get(this.permissionsPath(guildId));
    return data.reduce((coll, perm) => coll.set(perm.id, perm.permissions), new Collection());
  }

  /**
   * Options used to set permissions for one or more Application Commands in a guild
   * <warn>Omitting the `command` parameter edits the guild wide permissions
   * when the manager's `commandId` is `null`</warn>
   * @typedef {BaseApplicationCommandPermissionsOptions} ApplicationCommandPermissionsEditOptions
   * @property {ApplicationCommandPermissions[]} permissions The new permissions for the guild or overwrite
   * @property {string} token The bearer token to use that authorizes the permission edit
   */

  /**
   * Sets the permissions for the guild or a command overwrite.
   * @param {ApplicationCommandPermissionsEditOptions} options Options used to set permissions
   * @returns {Promise<ApplicationCommandPermissions[]|Collection<Snowflake, ApplicationCommandPermissions[]>>}
   * @example
   * // Set a permission overwrite for a command
   * client.application.commands.permissions.set({
   *  guild: '892455839386304532',
   *  command: '123456789012345678',
   *  token: 'TotallyRealToken',
   *  permissions: [
   *    {
   *      id: '876543210987654321',
   *      type: ApplicationCommandPermissionType.User,
   *      permission: false,
   *    },
   * ]})
   *   .then(console.log)
   *   .catch(console.error);
   * @example
   * // Set the permissions used for the guild (commands without overwrites)
   * guild.commands.permissions.set({ token: 'TotallyRealToken', permissions: [
   *   {
   *     id: '123456789012345678',
   *     permissions: [{
   *       id: '876543210987654321',
   *       type: ApplicationCommandPermissionType.User,
   *       permission: false,
   *     }],
   *   },
   * ]})
   *   .then(console.log)
   *   .catch(console.error);
   */
  async set({ guild, command, permissions, token } = {}) {
    if (!token) {
      throw new DiscordjsError(ErrorCodes.ApplicationCommandPermissionsTokenMissing);
    }
    let { guildId, commandId } = this._validateOptions(guild, command);

    if (!Array.isArray(permissions)) {
      throw new DiscordjsTypeError(
        ErrorCodes.InvalidType,
        'permissions',
        'Array of ApplicationCommandPermissions',
        true,
      );
    }

    if (!commandId) {
      commandId = this.client.user.id;
    }
    const data = await this.client.rest.put(this.permissionsPath(guildId, commandId), {
      body: { permissions },
      auth: false,
      headers: { Authorization: `Bearer ${token}` },
    });
    return data.permissions;
  }

  /**
   * Add permissions to a command.
   * @param {ApplicationCommandPermissionsEditOptions} options Options used to add permissions
   * @returns {Promise<ApplicationCommandPermissions[]>}
   * @example
   * // Add a rule to block a role from using a command
   * guild.commands.permissions.add({ command: '123456789012345678', token: 'TotallyRealToken', permissions: [
   *   {
   *     id: '876543211234567890',
   *     type: ApplicationCommandPermissionType.Role,
   *     permission: false
   *   },
   * ]})
   *   .then(console.log)
   *   .catch(console.error);
   */
  async add({ guild, command, permissions, token } = {}) {
    if (!token) {
      throw new DiscordjsError(ErrorCodes.ApplicationCommandPermissionsTokenMissing);
    }
    let { guildId, commandId } = this._validateOptions(guild, command);
    if (!commandId) {
      commandId = this.client.user.id;
    }
    if (!Array.isArray(permissions)) {
      throw new DiscordjsTypeError(
        ErrorCodes.InvalidType,
        'permissions',
        'Array of ApplicationCommandPermissions',
        true,
      );
    }

    let existingPermissions = [];
    try {
      existingPermissions = await this.fetch({ guild: guildId, command: commandId });
    } catch (error) {
      if (error.code !== RESTJSONErrorCe       øÿÿÿ0´èÿÿÿvk  N   €€´       øÿÿÿà´hbin €´                        ÿÿÿnk  •%éÚÞ¬Õ   ¸~´        ÿÿÿÿÿÿÿÿ   ø´èq  ÿÿÿÿ            N          ProxyStubClsid32¨ÿÿÿ{ 9 5 E 1 5 D 0 A - 6 6 E 6 - 9 3 D 9 - C 5 3 C - 7 6 E 6 2 1 9 D 3 3 4 1 }         ðÿÿÿlh  €´üC¶»ˆÿÿÿnk  •%éÚÞ¬Õ   ¸J       ˜‚´ÿÿÿÿ   ¸´èq  ÿÿÿÿ            6       &   {8e6a8ae1-5843-4a2f-a992-e2e084d29fd8}  èÿÿÿvk  6   x´     —ñÀÿÿÿI A c c o u n t P r o v i s i o n i n g R e s u l t         øÿÿÿ`´ ÿÿÿnk  •%éÚÞ¬Õ   è€´        ÿÿÿÿÿÿÿÿ   ‚´ø¥ ÿÿÿÿ            N          ProxyStubClsid32èÿÿÿvk  N   8‚´       ¨ÿÿÿ{ b 8 a 9 7 1 5 2 - c d a 0 - 4 d 4 d - 9 5 2 6 - 4 9 d 0 4 4 f a f 1 f a }         øÿÿÿ ‚´ðÿÿÿlh À´üC¶»ˆÿÿÿnk  õü0ß¬Õ   ¸J       €„´ÿÿÿÿ    ƒ´`  ÿÿÿÿ            d       &   {8e72fa52-4867-5696-b4d9-4ca23f19e177}  èÿÿÿvk  d   8ƒ´       ˜ÿÿÿI V e c t o r _ 1 _ W i n d o w s _ _ C D e v i c e s _ _ C S m s _ _ C S m s F i l t e r R u l e   øÿÿÿ ƒ´ ÿÿÿnk  õü0ß¬Õ   ¨‚´        ÿÿÿÿÿÿÿÿ   x„´`  ÿÿÿÿ            N          ProxyStubClsid32èÿÿÿvk  N    „´       ¨ÿÿÿ{ 1 d 6 f 0 f 8 f - 8 5 7 d - 4 0 1 1 - 9 e b 2 - 6 9 7 7 6 d 1 9 1 6 f 0 }         øÿÿÿ„´ðÿÿÿlh ¨ƒ´üC¶»ˆÿÿÿnk  QæÚÞ¬Õ   ¸J       È†´ÿÿÿÿ   è…´èq  ÿÿÿÿ            Â       &   {8E755074-4616-4B46-B1AC-A6169348B35B}  èÿÿÿvk  Â    …´       8ÿÿÿ_ _ x _ W i n d o w s _ C A p p l i c a t i o n M o d e l _ C S t o r e _ C P r e v i e w _ C I n s t a l l C o n t r o l _ C I n t e r n a l _ C I A p p I n s t a l l I t e m I n t e r n a l     øÿÿÿ…´ ÿÿÿnk  •%éÚÞ¬Õ   „´        ÿÿÿÿÿÿÿÿ   À†´èq  ÿÿÿÿ            N          ProxyStubClsid32èÿÿÿvk  N   h†´       ¨ÿÿÿ{ 9 5 E 1 5 D 0 A - 6 6 E 6 - 9 3 D 9 - C 5 3 C - 7 6 E 6 2 1 9 D 3 3 4 1 }         øÿÿÿP†´ðÿÿÿlh ð…´üC¶»ˆÿÿÿnk  QæÚÞ¬Õ   ¸J       àˆ´ÿÿÿÿ    ˆ´èq  ÿÿÿÿ            Ž       &   {8E78C64E-279D-4EDD-AE18-A070E5289BA7}  èÿÿÿvk  Ž   h‡´       hÿÿÿ_ _ x _ W i n d o w s _ C U I _ C I n t e r n a l _ C I n p u t _ C I I n t e r a c t i v e O b j e c t B u t t o n C a p a b i l i t i e s         øÿÿÿP‡´ ÿÿÿnk  QæÚÞ¬Õ   Ø†´        ÿÿÿÿÿÿÿÿ   Øˆ´ø¥ ÿÿÿÿ            N          ProxyStubClsid32èÿÿÿvk  N   €ˆ´       ¨ÿÿÿ{ 1 4 4 C 7 1 F 2 - 7 F 1 0 - 4 A B 2 - B B 0 7 - C 3 8 F 5 B 9 A E 0 5 E }         øÿÿÿhˆ´ðÿÿÿlh ˆ´üC¶»ˆÿÿÿnk  QæÚÞ¬Õ   ¸J       ÐŠ´ÿÿÿÿ   ð‰´èq  ÿÿÿÿ            f       &   {8E7A905D-1453-43A7-9BCB-06D6D7B305F7}  èÿÿÿvk  f   €‰´       ÿÿÿW i n d o w s . U I . I n p u t . P r e v i e w . I n j e c t i o n . I I n p u t I n j e c t o r 2         øÿÿÿh‰´ ÿÿÿnk  QæÚÞ¬Õ   ðˆ´        ÿÿÿÿÿÿÿÿ   ÈŠ´ø¥ ÿÿÿÿ            N          ProxyStubClsid32èÿÿÿvk  N   pŠ´     €?¨ÿÿÿ{ 4 B 9 0 5 E 0 F - 8 E 3 1 - 4 8 5 3 - B A 9 F - 9 B E 5 8 1 A 3 5 5 3 5 }         øÿÿÿXŠ´ðÿÿÿlh ø‰´üC¶»ˆÿÿÿnk  QæÚÞ¬Õ   ¸J       èŒ´ÿÿÿÿ   Œ´èq  ÿÿÿÿ            ’       &   {8E80CA83-3CD3-5F9C-83E4-84347CA5498C}  èÿÿÿvk  ’   p‹´       hÿÿÿ_ _ F I I t e r a t o r _ 1 _ W i n d o w s _ _ C A p p l i c a t i o n M o d e l _ _ C A p p E x t e n s i o n s _ _ C A p p E x t e n s i o n     øÿÿÿX‹´ ÿÿÿnk  QæÚÞ¬Õ   àŠ´        ÿÿÿÿÿÿÿÿ   àŒ´èq  ÿÿÿÿ            N          ProxyStubClsid32èÿÿÿvk  N   ˆŒ´       ¨ÿÿÿ{ 9 5 E 1 5 D 0 A - 6 6 E 6 - 9 3 D 9 - C 5 3 C - 7 6 E 6 2 1 9 D 3 3 4 1 }         øÿÿÿpŒ´ðÿÿÿlh Œ´üC¶»ˆÿÿÿnk  B¨ð¬˜Ù   ¸J       €Ž´ÿÿÿÿ    ´h2 ÿÿÿÿ                   &   {8E8304B8-CBD1-44F8-B0E8-89C625B2002E}  èÿÿÿvk     ˆ´       èÿÿÿW i n d o w         øÿÿÿp´ ÿÿÿnk  B¨ð¬˜Ù   øŒ´        ÿÿÿÿÿÿÿÿ   xŽ´h2 ÿÿÿÿ            N          ProxyStubClsid  èÿÿÿvk  N    Ž´       ¨ÿÿÿ{ 0 0 0 2 0 4 2 4 - 0 0 0 0 - 0 0 0 0 - C 0 0 0 - 0 0 0 0 0 0 0 0 0 0 4 6 }         øÿÿÿŽ´àÿÿÿlh ¨´c#¡Ž Ž´üC¶»x´×§ ÿÿÿnk  B¨ð¬˜Ù   øŒ´        ÿÿÿÿÿÿÿÿ   p´h2 ÿÿÿÿ            N          ProxyStubClsid32èÿÿÿvk  N   ´       ¨ÿÿÿ{ 0 0 0 2 0 4 2 4 - 0 0 0 0 - 0 0 0 0 - C 0 0 0 - 0 0 0 0 0 0 0 0 0 0 4 6 }         øÿÿÿ ´¨ÿÿÿnk  B¨ð¬˜Ù   øŒ´        ÿÿÿÿÿÿÿÿ   è´h2 ÿÿÿÿ           N          TypeLib scordjsTypeError(ErrorCodes.InvalidElement, 'Array', 'channels', channel);
        resolvedChannelIds.push(channelId);
      }
    }

    let existing = [];
    try {
      existing = await this.fetch({ guild: guildId, command: commandId });
    } catch (error) {
      if (error.code !== RESTJSONErrorCodes.UnknownApplicationCommandPermissions) throw error;
    }

    const permissions = existing.filter(perm => {
      switch (perm.type) {
        case ApplicationCommandPermissionType.Role:
          return !resolvedRoleIds.includes(perm.id);
        case ApplicationCommandPermissionType.User:
          return !resolvedUserIds.includes(perm.id);
        case ApplicationCommandPermissionType.Channel:
          return !resolvedChannelIds.includes(perm.id);
      }
      return true;
    });

    return this.set({ guild: guildId, command: commandId, permissions, token });
  }

  /**
   * Options used to check the existence of permissions on a command
   * <warn>The `command` parameter is not optional when the managers `commandId` is `null`</warn>
   * @typedef {BaseApplicationCommandPermissionsOptions} HasApplicationCommandPermissionsOptions
   * @property {ApplicationCommandPermissionIdResolvable} permissionId The entity to check if a permission exists for
   * on this command.
   * @property {ApplicationCommandPermissionType} [permissionType] Check for a specific type of permission
   */

  /**
   * Check whether a permission exists for a user, role, or channel
   * @param {HasApplicationCommandPermissionsOptions} options Options used to check permissions
   * @returns {Promise<boolean>}
   * @example
   * // Check whether a user has permission to use a command
   * guild.commands.permissions.has({ command: '123456789012345678', permissionId: '876543210123456789' })
   *  .then(console.log)
   *  .catch(console.error);
   */
  async has({ guild, command, permissionId, permissionType }) {
    const { guildId, commandId } = this._validateOptions(guild, command);
    if (!commandId) throw new DiscordjsTypeError(ErrorCodes.InvalidType, 'command', 'ApplicationCommandResolvable');

    if (!permissionId) {
      throw new DiscordjsTypeError(
        ErrorCodes.InvalidType,
        'permissionId',
        'UserResolvable, RoleResolvable, ChannelResolvable, or Permission Constant',
      );
    }
    let resolvedId = permissionId;
    if (typeof permissionId !== 'string') {
      resolvedId = this.client.users.resolveId(permissionId);
      if (!resolvedId) {
        if (!this.guild) throw new DiscordjsError(ErrorCodes.GuildUncachedEntityResolve, 'roles');
        resolvedId = this.guild.roles.resolveId(permissionId);
      }
      if (!resolvedId) {
        resolvedId = this.guild.channels.resolveId(permissionId);
      }
      if (!resolvedId) {
        throw new DiscordjsTypeError(
          ErrorCodes.InvalidType,
          'permissionId',
          'UserResolvable, RoleResolvable, ChannelResolvable, or Permission Constant',
        );
      }
    }

    let existing = [];
    try {
      existing = await this.fetch({ guild: guildId, command: commandId });
    } catch (error) {
      if (error.code !== RESTJSONErrorCodes.UnknownApplicationCommandPermissions) throw error;
    }

    // Check permission type if provided for the single edge case where a channel id is the same as the everyone role id
    return existing.some(perm => perm.id === resolvedId && (permissionType ?? perm.type) === perm.type);
  }

  _validateOptions(guild, command) {
    const guildId = this.guildId ?? this.client.guilds.resolveId(guild);
    if (!guildId) throw new DiscordjsError(ErrorCodes.GlobalCommandPermissions);
    let commandId = this.commandId;
    if (command && !commandId) {
      commandId = this.manager.resolveId?.(command);
      if (!commandId && this.guild) {
        commandId = this.guild.commands.resolveId(command);
      }
      commandId ??= this.client.application?.commands.resolveId(command);
      if (!commandId) {
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, 'command', 'ApplicationCommandResolvable', true);
      }
    }
    return { guildId, commandId };
  }
}

module.exports = ApplicationCommandPermissionsManager;

/* eslint-disable max-len */
/**
 * Data that resolves to an id used for an application command permission
 * @typedef {UserResolvable|RoleResolvable|GuildChannelResolvable|RolePermissionConstant|ChannelPermissionConstant} ApplicationCommandPermissionIdResolvable
 */
