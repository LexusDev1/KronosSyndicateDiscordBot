var mapping = require('./_mapping'),
    fallbackHolder = require('./placeholder');

/** Built-in value reference. */
var push = Array.prototype.push;

/**
 * Creates a function, with an arity of `n`, that invokes `func` with the
 * arguments it receives.
 *
 * @private
 * @param {Function} func The function to wrap.
 * @param {number} n The arity of the new function.
 * @returns {Function} Returns the new function.
 */
function baseArity(func, n) {
  return n == 2
    ? function(a, b) { return func.apply(undefined, arguments); }
    : function(a) { return func.apply(undefined, arguments); };
}

/**
 * Creates a function that invokes `func`, with up to `n` arguments, ignoring
 * any additional arguments.
 *
 * @private
 * @param {Function} func The function to cap arguments for.
 * @param {number} n The arity cap.
 * @returns {Function} Returns the new function.
 */
function baseAry(func, n) {
  return n == 2
    ? function(a, b) { return func(a, b); }
    : function(a) { return func(a); };
}

/**
 * Creates a clone of `array`.
 *
 * @private
 * @param {Array} array The array to clone.
 * @returns {Array} Returns the cloned array.
 */
function cloneArray(array) {
  var length = array ? array.length : 0,
      result = Array(length);

  while (length--) {
    result[length] = array[length];
  }
  return result;
}

/**
 * Creates a function that clones a given object using the assignment `func`.
 *
 * @private
 * @param {Function} func The assignment function.
 * @returns {Function} Returns the new cloner function.
 */
function createCloner(func) {
  return function(object) {
    return func({}, object);
  };
}

/**
 * A specialized version of `_.spread` which flattens the spread array into
 * the arguments of the invoked `func`.
 *
 * @private
 * @param {Function} func The function to spread arguments over.
 * @param {number} start The start position of the spread.
 * @returns {Function} Returns the new function.
 */
function flatSpread(func, start) {
  return function() {
    var length = arguments.length,
        lastIndex = length - 1,
        args = Array(length);

    while (length--) {
      args[length] = arguments[length];
    }
    var array = args[start],
        otherArgs = args.slice(0, start);

    if (array) {
      push.apply(otherArgs, array);
    }
    if (start != lastIndex) {
      push.apply(otherArgs, args.slice(start + 1));
    }
    return func.apply(this, otherArgs);
  };
}

/**
 * Creates a function that wraps `func` and uses `cloner` to clone the first
 * argument it receives.
 *
 * @private
 * @param {Function} func The function to wrap.
 * @param {Function} cloner The function to clone arguments.
 * @returns {Function} Returns the new immutable function.
 */
function wrapImmutable(func, cloner) {
  return function() {
    var length = arguments.length;
    if (!length) {
      return;
    }
    var args = Array(length);
    while (length--) {
      args[length] = arguments[length];
    }
    var result = args[0] = cloner.apply(undefined, args);
    func.apply(undefined, args);
    return result;
  };
}

/**
 * The base implementation of `convert` which accepts a `util` object of methods
 * required to perform conversions.
 *
 * @param {Object} util The util object.
 * @param {string} name The name of the function to convert.
 * @param {Function} func The function to convert.
 * @param {Object} [options] The options object.
 * @param {boolean} [options.cap=true] Specify capping iteratee arguments.
 * @param {boolean} [options.curry=true] Specify currying.
 * @param {boolean} [options.fixed=true] Specify fixed arity.
 * @param {boolean} [options.immutable=true] Specify immutable operations.
 * @param {boolean} [options.rearg=true] Specify rearranging arguments.
 * @returns {Function|Object} Returns the converted function or object.
 */
function baseConvert(util, name, func, options) {
  var isLib = typeof name == 'function',
      isObj = name === Object(name);

  if (isObj) {
    options = func;
    func = name;
    name = undefined;
  }
  if (func == null) {
    throw new TypeError;
  }
  options || (options = {});

  var config = {
    'cap': 'cap' in options ? options.cap : true,
    'curry': 'curry' in options ? options.curry : true,
    'fixed': 'fixed' in options ? options.fixed : true,
    'immutable': 'immutable' in options ? options.immutable : true,
    'rearg': 'rearg' in options ? options.rearg : true
  };

  var defaultHolder = isLib ? func : fallbackHolder,
      forceCurry = ('curry' in options) && options.curry,
      forceFixed = ('fixed' in options) && options.fixed,
      forceRearg = ('rearg' in options) && options.rearg,
      pristine = isLib ? func.runInContext() : undefined;

  var helpers = isLib ? func : {
    'ary': util.ary,
    'assign': util.assign,
    'clone': util.clone,
    'curry': util.curry,
    'forEach': util.forEach,
    'isArray': util.isArray,
    'isError': util.isError,
    'isFunction': util.isFunction,
    'isWeakMap': util.isWeakMap,
    'iteratee': util.iteratee,
    'keys': util.keys,
    'rearg': util.rearg,
    'toInteger': util.toInteger,
    'toPath': util.toPath
  };

  var ary = helpers.ary,
      assign = helpers.assign,
      clone = helpers.clone,
      curry = helpers.curry,
      each = helpers.forEach,
      isArray = helpers.isArray,
      isError = helpers.isError,
      isFunction = helpers.isFunction,
      isWeakMap = helpers.isWeakMap,
      keys = helpers.keys,
      rearg = helpers.rearg,
      toInteger = helpers.toInteger,
      toPath = helpers.toPath;

  var aryMethodKeys = keys(mapping.aryMethod);

  var wrappers = {
    'castArray': function(castArray) {
      return function() {
        var value = arguments[0];
        return isArray(value)
          ? castArray(cloneArray(value))
          : castArray.apply(undefined, arguments);
      };
    },
    'iteratee': function(iteratee) {
      return function() {
        var func = arguments[0],
            arity = arguments[1],
            result = iteratee(func, arity),
            length = result.length;

        if (config.cap && typeof arity == 'number') {
          arity = arity > 2 ? (arity - 2) : 1;
          return (length && length <= arity) ? result : baseAry(result, arity);
        }
        return result;
      };
    },
    'mixin': function(mixin) {
      return function(source) {
        var func = this;
        if (!isFunction(func)) {
          return mixin(func, Object(source));
        }
        var pairs = [];
        each(keys(source), function(key) {
          if (isFunction(source[key])) {
            pairs.push([key, func.prototype[key]]);
          }
        });

        mixin(func, Object(source));

        each(pairs, function(pair) {
          var value = pair[1];
          if (isFunction(value)) {
            func.prototype[pair[0]] = value;
          } else {
            delete func.prototype[pair[0]];
          }
        });
        return func;
      };
    },
    'nthArg': function(nthArg) {
      return function(n) {
        var arity = n < 0 ? 1 : (toInteger(n) + 1);
        return curry(nthArg(n), arity);
      };
    },
    'rearg': function(rearg) {
      return function(func, indexes) {
        var arity = indexes ? indexes.length : 0;
        return curry(rearg(func, indexes), arity);
      };
    },
    'runInContext': function(runInContext) {
      return function(context) {
        return baseConvert(util, runInContext(context), options);
      };
    }
  };

  /*--------------------------------------------------------------------------*/

  /**
   * Casts `func` to a function with an arity capped iteratee if needed.
   *
   * @private
   * @param {string} name The name of the function to inspect.
   * @param {Function} func The function to inspect.
   * @returns {Function} Returns the cast function.
   */
  function castCap(name, func) {
    if (config.cap) {
      var indexes = mapping.iterateeRearg[name];
      if (indexes) {
        return iterateeRearg(func, indexes);
      }
      var n = !isLib && mapping.iterateeAry[name];
      if (n) {
        return iterateeAry(func, n);
      }
    }
    return func;
  }

  /**
   * Casts `func` to a curried function if needed.
   *
   * @private
   * @param {string} name The name of the function to inspect.
   * @param {Function} func The function to inspect.
   * @param {number} n The arity of `func`.
   * @returns {Function} Returns the cast function.
   */
  function castCurry(name, func, n) {
    return (forceCurry || (config.curry && n > 1))
      ? curry(func, n)
      : func;
  }

  /**
   * Casts `func` to a fixed arity function if needed.
   *
   * @private
   * @param {string} name The name of the function to inspect.
   * @param {Function} func The function to inspect.
   * @param {number} n The arity cap.
   * @returns {Function} Returns the cast function.
   */
  function castFixed(name, func, n) {
    if (config.fixed && (forceFixed || !mapping.skipFixed[name])) {
      var data = mapping.methodSpread[name],
          start = data && data.start;

      return start  === undefined ? ary(func, n) : flatSpread(func, start);
    }
    return func;
  }

  /**
   * Casts `func` to an rearged function if needed.
   *
   * @private
   * @param {string} name The name of the function to inspect.
   * @param {Function} func The function to inspect.
   * @param {number} n The arity of `func`.
   * @returns {Function} Returns the cast function.
   */
  function castRearg(name, func, n) {
    return (config.rearg && n > 1 && (forceRearg || !mapping.skipRearg[name]))
      ? rearg(func, mapping.methodRearg[name] || mapping.aryRearg[n])
      : func;
  }

  /**
   * Creates a clone of `object` by `path`.
   *
   * @private
   * @param {Object} object The object to clone.
   * @param {Array|string} path The path to clone by.
   * @returns {Object} Returns the cloned object.
   */
  function cloneByPath(object, path) {
    path = toPath(path);

    var index = -1,
        length = path.length,
        lastIndex = length - 1,
        result = clone(Object(object)),
        nested = result;

    while (nested != null && ++index < length) {
      var key = path[index],
          value = nested[key];

      if (value != null &&
          !(isFunction(value) || isError(value) || isWeakMap(value))) {
        nested[key] = clone(index == lastIndex ? value : Object(value));
      }
      nested = nested[key];
    }
    return result;
  }

  /**
   * Converts `lodash` to an immutable auto-curried iteratee-first data-last
   * version with conversion `options` applied.
   *
   * @param {Object} [options] The options object. See `baseConvert` for more details.
   * @returns {Function} Returns the converted `lodash`.
   */
  function convertLib(options) {
    return _.runInContext.convert(options)(undefined);
  }

  /**
   * Create a converter function for `func` of `name`.
   *
   * @param {string} name The name of the function to convert.
   * @param {Function} func The function to convert.
   * @returns {Function} Returns the new converter function.
   */
  function createConverter(name, func) {
    var realName = mapping.aliasToReal[name] || name,
        methodName = mapping.remap[realName] || realName,
        oldOptions = options;

    return function(options) {
      var newUtil = isLib ? pristine : helpers,
          newFunc = isLib ? pristine[methodName] : func,
          newOptions = assign(assign({}, oldOptions), options);

      return baseConvert(newUtil, realName, newFunc, newOptions);
    };
  }

  /**
   * Creates a function that wraps `func` to invoke its iteratee, with up to `n`
   * arguments, ignoring any additional arguments.
   *
   * @private
   * @param {Function} func The function to cap iteratee arguments for.
   * @param {number} n The arity cap.
   * @returns {Function} Returns the new function.
   */
  function iterateeAry(func, n) {
    return overArg(func, function(func) {
      return typeof func == 'function' ? baseAry(func, n) : func;
    });
  }

  /**
   * Creates a function that wraps `func` to invoke its iteratee with arguments
   * arranged according to the specified `indexes` where the argument value at
   * the first index is provided as the first argument, the argument value at
   * the seco l l m e n t   øÿÿÿ8Ñèÿÿÿvk  N   €Ñ       hbin Ñ                        ÿÿÿnk  –ÕâÙŞ¬Õ   ÀÑ        ÿÿÿÿÿÿÿÿ   ØÑèq  ÿÿÿÿ            N          ProxyStubClsid32¨ÿÿÿ{ 3 F B F 6 0 B D - 9 0 B 2 - 2 C 2 F - 7 2 8 6 - 1 2 8 B B C F 7 2 0 1 5 }         øÿÿÿèÑğÿÿÿlh  ÑüC¶»ˆÿÿÿnk  Ë'1ß¬Õ   ¸J       ˜’Ñÿÿÿÿ   ¸‘Ñ`  ÿÿÿÿ            0       &   {BDDE0EEE-3B8D-4C82-B529-33F16B42832E}  èÿÿÿvk  0   €‘Ñ       ÈÿÿÿI D e b u g D o c u m e n t P o s i t i o n 2       øÿÿÿh‘Ñ ÿÿÿnk  Ë'1ß¬Õ   ğÑ        ÿÿÿÿÿÿÿÿ   ’Ñ`  ÿÿÿÿ            N          ProxyStubClsid32èÿÿÿvk  N   8’Ñ       ¨ÿÿÿ{ C 5 6 2 1 3 6 4 - 8 7 C C - 4 7 3 1 - 8 9 4 7 - 9 2 9 C A E 7 5 3 2 3 E }         øÿÿÿ ’Ñğÿÿÿlh À‘ÑüC¶»ˆÿÿÿnk  á†úAä¬Õ   ¸J       ø“Ñÿÿÿÿ    ÿÿÿÿèq  ÿÿÿÿ                    &   {bdded7c0-5c73-57f5-9b08-652933586dd5}   ÿÿÿnk  á†úAä¬Õ   ¨’Ñ        ÿÿÿÿÿÿÿÿ   ğ“Ñø¥ ÿÿÿÿ            N          ProxyStubClsid32èÿÿÿvk  N   ˜“Ñ       ¨ÿÿÿ{ 0 b 4 c 2 2 7 f - 2 3 9 4 - 4 3 f f - b a 5 9 - b c 7 6 2 f 5 c 4 6 e a }    P   øÿÿÿ€“Ñğÿÿÿlh  “ÑüC¶»ˆÿÿÿnk  –ÕâÙŞ¬Õ   ¸J       °•Ñÿÿÿÿ   Ğ”Ñèq  ÿÿÿÿ            2       &   {BDE1D4EF-5C0E-4479-BDF2-BEAE34EE3A72}  èÿÿÿvk  2   ˜”Ñ       ÈÿÿÿI S h e l l B r o k e r e d O p e r a t i o n s     øÿÿÿ€”Ñ ÿÿÿnk  –ÕâÙŞ¬Õ   ”Ñ        ÿÿÿÿÿÿÿÿ   ¨•Ñèq  ÿÿÿÿ            N          ProxyStubClsid32èÿÿÿvk  N   P•Ñ       ¨ÿÿÿ{ 9 5 E 1 5 D 0 A - 6 6 E 6 - 9 3 D 9 - C 5 3 C - 7 6 E 6 2 1 9 D 3 3 4 1 }         øÿÿÿ8•Ñğÿÿÿlh Ø”ÑüC¶»ˆÿÿÿnk  –ÕâÙŞ¬Õ   ¸J       `—Ñÿÿÿÿ   €–Ñèq  ÿÿÿÿ            *       &   {BDE26D2E-140B-4AEE-A4CE-0C4E7DF6C1B1}  èÿÿÿvk  *   P–Ñ       ĞÿÿÿI S h e l l W e b B r o w s e r P r i v     øÿÿÿ8–Ñ ÿÿÿnk  –ÕâÙŞ¬Õ   À•Ñ        ÿÿÿÿÿÿÿÿ   X—Ñèq  ÿÿÿÿ            N          ProxyStubClsid32èÿÿÿvk  N    —Ñ       ¨ÿÿÿ{ C 9 0 2 5 0 F 3 - 4 D 7 D - 4 9 9 1 - 9 B 6 9 - A 5 C 5 B C 1 C 2 A E 6 }         øÿÿÿè–Ñğÿÿÿlh ˆ–ÑüC¶»ˆÿÿÿnk  –ÕâÙŞ¬Õ   ¸J       8™Ñÿÿÿÿ   X˜Ñèq  ÿÿÿÿ            P       &   {bdea44aa-b64a-56b5-8636-9ae88b242de1}  èÿÿÿvk  P    ˜Ñ       ¨ÿÿÿI I t e r a t o r < I K e y V a l u e P a i r < H S T R I N G , b y t e >   >       øÿÿÿè—Ñ ÿÿÿnk  –ÕâÙŞ¬Õ   p—Ñ        ÿÿÿÿÿÿÿÿ   0™Ñèq  ÿÿÿÿ            N          ProxyStubClsid32èÿÿÿvk  N   Ø˜Ñ       ¨ÿÿÿ{ 1 1 6 5 9 a 2 3 - 5 8 8 4 - 4 d 1 b - 9 c f 6 - 6 7 d 6 f 4 f 9 0 b 3 6 }         øÿÿÿÀ˜Ñğÿÿÿlh `˜ÑüC¶»ˆÿÿÿnk  º3mÆ¬˜Ù   ¸J       ØšÑÿÿÿÿ   ø™Ñh2 ÿÿÿÿ                   &   {BDEADE99-C265-11D0-BCED-00A0C90AB50F}  èÿÿÿvk     Ø™Ñ       àÿÿÿI O W S P o s t D a t a     øÿÿÿÀ™Ñ ÿÿÿnk  º3mÆ¬˜Ù   H™Ñ        ÿÿÿÿÿÿÿÿ   ĞšÑh2 ÿÿÿÿ            N          ProxyStubClsid  èÿÿÿvk  N   xšÑ       ¨ÿÿÿ{ 0 0 0 2 0 4 2 4 - 0 0 0 0 - 0 0 0 0 - C 0 0 0 - 0 0 0 0 0 0 0 0 0 0 4 6 }         øÿÿÿ`šÑàÿÿÿlh  šÑc#¡øšÑüC¶»Ğ›Ñ×§ ÿÿÿnk  º3mÆ¬˜Ù   H™Ñ        ÿÿÿÿÿÿÿÿ   È›Ñh2 ÿÿÿÿ            N          ProxyStubClsid32èÿÿÿvk  N   p›Ñ     §¨ÿÿÿ{ 0 0 0 2 0 4 2 4 - 0 0 0 0 - 0 0 0 0 - C 0 0 0 - 0 0 0 0 0 0 0 0 0 0 4 6 }         øÿÿÿX›Ñ¨ÿÿÿnk  º3mÆ¬˜Ù   H™Ñ        ÿÿÿÿÿÿÿÿ   ˜œÑh2 ÿÿÿÿ           N          TypeLib èÿÿÿvk  N   @œÑ       ¨ÿÿÿ{ B D E A D E 3 3 - C 2 6 5 - 1 1 D 0 - B C E D - 0 0 A 0 C 9 0 A B 5 0 F }         ğÿÿÿ(œÑ¨œÑ    àÿÿÿvk    ÈœÑ      Version ğÿÿÿ2 . 0       ˆÿÿÿnk  º3mÆ¬˜Ù   ¸J       xÑÿÿÿÿ   ˜Ñh2 ÿÿÿÿ            ,       &   {BDEADE9A-C265-11D0-BCED-00A0C90AB50F}  èÿÿÿvk  ,   hÑ       Ğÿÿÿ_ I O W S P o s t D a t a R e s p o n s e   øÿÿÿPÑ ÿÿÿnk  º3mÆ¬˜Ù   ØœÑ        ÿÿÿÿÿÿÿÿ   pÑh2 ÿÿÿÿ            N          ProxyStubClsid  èÿÿÿvk  N   Ñ       ¨ÿÿÿ{ 0 0 0 2 0 4 2 0 - 0 0 0 0 - 0 0 0 0 - C 0 0 0 - 0 0 0 0 0 0 0 0 0 0 4 6 }         øÿÿÿ Ñàÿÿÿlh  Ñc#¡˜ÑüC¶»pŸÑ×§ ÿÿÿnk  º3mÆ¬˜Ù   ØœÑ        ÿÿÿÿÿÿÿÿ   hŸÑh2 ÿÿÿÿ            N          ProxyStubClsid32èÿÿÿvk  N   ŸÑ     §¨ÿÿÿ{ 0 0 0 2 0 4 2 0 - 0 0 0 0 - 0 0 0 0 - C 0 0 0 - 0 0 0 0 0 0 0 0 0 0 4 6 }         øÿÿÿøÑ¨ÿÿÿnk  º3mÆ¬˜Ù   ØœÑ        ÿÿÿÿÿÿÿÿ   àŸÑh2 ÿÿÿÿ           N          TypeLib èÿÿÿvk  N     Ñ       ğÿÿÿÈŸÑx Ñ  